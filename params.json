{
  "name": "SwiftSockets",
  "tagline": "A simple GCD based socket wrapper for Swift.",
  "body": "SwiftSockets\r\n============\r\n![Mac OS X](https://img.shields.io/badge/os-Mac%20OS%20X-green.svg?style=flat)\r\n![iOS](https://img.shields.io/badge/os-iOS-green.svg?style=flat)\r\n![Linux](https://img.shields.io/badge/os-linux-green.svg?style=flat)\r\n![MIT](https://img.shields.io/badge/license-MIT-blue.svg?style=flat)\r\n\r\nA simple GCD based socket library for Swift.\r\n\r\nSwiftSockets is kind of a demo on how to integrate Swift with raw C APIs. More\r\nfor stealing Swift coding ideas than for actually using the code in a real\r\nworld project. In most real world Swift apps you have access to Cocoa, use it.\r\n\r\nIt also comes with a great Echo daemon as a demo, it's always there if you need\r\na chat.\r\n\r\n**Note**: This is my first [Swift](https://developer.apple.com/swift/) project.\r\nAny suggestions on how to improve the code are welcome. I expect lots and lots\r\n:-)\r\n\r\n###Targets\r\n\r\nThe project includes three targets:\r\n- SwiftSockets\r\n- ARIEchoServer\r\n- ARIFetch\r\n\r\nUpdated for Swift 0.2.2 (aka Xcode 7.3), aand for Swift 0.3-2016-05-09.\r\n\r\n*Note for Linux users*:\r\nThis compiles with the 2016-03-01-a snapshot via Swift Package Manager\r\nas well as with the Swift 2.2 release using the embedded makefiles.\r\nMake sure you \r\n[install Grand Central Dispatch](http://www.alwaysrightinstitute.com/swift-on-linux-in-vbox-on-osx/)\r\ninto your Swift installation.\r\nOn Linux the included ARIEchoServer/ARIFetch apps do not build, but this one\r\ndoes and is embedded:\r\n[SwiftyEchoDaemon](http://www.alwaysrightinstitute.com/SwiftyEchoDaemon/).\r\n\r\n####SwiftSockets\r\n\r\nA framework containing the socket classes and relevant extensions. It takes a\r\nbit of inspiration from the [SOPE](http://sope.opengroupware.org) NGStreams\r\nlibrary.\r\n\r\nServer Sample:\r\n```swift\r\nlet socket = PassiveSocket<sockaddr_in>(address: sockaddr_in(port: 4242))!\r\n  .listen(queue: dispatch_get_global_queue(0, 0), backlog: 5) {\r\n    print(\"Wait, someone is attempting to talk to me!\")\r\n    $0.close()\r\n    print(\"All good, go ahead!\")\r\n  }\r\n```\r\n\r\nClient Sample:\r\n```swift\r\nlet socket = ActiveSocket<sockaddr_in>()!\r\n  .onRead { sock, _ in\r\n    let (count, block, errno) = sock.read() // $0 for sock doesn't work anymore?\r\n    guard count > 0 else {\r\n      print(\"EOF, or great error handling \\(errno).\")\r\n      return\r\n    }\r\n    print(\"Answer to ring,ring is: \\(count) bytes: \\(block)\")\r\n  }\r\n  .connect(\"127.0.0.1:80\") { socket in\r\n    socket.write(\"Ring, ring!\\r\\n\")\r\n  }\r\n```\r\n\r\n####Using SwiftSockets with Swift Package Manager\r\n\r\nTo use SwiftSockets in your SPM project, just add it as a dependency in your\r\n`Package.swift` file, like so:\r\n\r\n    import PackageDescription\r\n    \r\n    let package = Package(\r\n      name:         \"SwiftyEcho\",\r\n      targets:      [],\r\n      dependencies: [\r\n        .Package(url: \"https://github.com/AlwaysRightInstitute/SwiftSockets.git\",\r\n                 majorVersion: 0, minor: 1\r\n        )\r\n      ]\r\n    )\r\n\r\n\r\n####ARIEchoServer / SwiftyEchoDaemon\r\n\r\nThere is the ARIEchoServer for Xcode and SwiftEchoDaemon for Package Manager\r\ninstalls. Your choize, both are equally awezome.\r\n\r\nARIEchoServer is a Cocoa app. Compile it, run it, then\r\nconnect to it in the Terminal.app via ```telnet 1337```.\r\n\r\n![](http://i.imgur.com/874ovtE.png)\r\n\r\n[The **bezt** Echo daemon ever written in Swift](http://www.alwaysrightinstitute.com/SwiftyEchoDaemon/) - SPM version.\r\nThis is a demo on how to write a SwiftSockets server using the\r\nSwift Package Manager, on Linux or OSX.\r\nIt also works w/o SPM if SwiftSockets has been built\r\nvia Makefiles.\r\n\r\nGreat echo server. Compile it via `make`, run it via `make run`, then\r\nconnect to it in the Terminal.app via ```telnet 1337```.\r\n\r\n![](http://i.imgur.com/mzXANTC.png)\r\n\r\n####ARIFetch\r\n\r\nConnects a socket to some end point, sends an HTTP/1.0 GET request with some\r\nawesome headers, then shows the results the server sends. Cocoa app.\r\n\r\nWhy HTTP/1.0? Avoids redirects on www.apple.com :-)\r\n\r\n![](http://i.imgur.com/nRhADxg.png)\r\n\r\n\r\n###Goals\r\n\r\n- [x] Max line length: 80 characters\r\n- [ ] Great error handling\r\n  - [x] PS style great error handling\r\n  - [x] print() error handling\r\n  - [ ] Swift 2 try/throw/catch\r\n    - [ ] Real error handling\r\n- [x] Twisted (no blocking reads or writes)\r\n  - [x] Async reads and writes\r\n    - [x] Never block on reads\r\n    - [x] Never block on listen\r\n  - [ ] Async connect()\r\n- [ ] Support all types of Unix sockets & addresses\r\n  - [x] IPv4\r\n  - [ ] IPv6 (I guess this should work too)\r\n  - [ ] Unix domain sockets\r\n  - [ ] Datagram sockets\r\n- [x] No NS'ism\r\n- [ ] Use as many language features Swift provides\r\n  - [x] Generics\r\n    - [x] Generic function\r\n    - [x] typealias\r\n  - [x] Closures\r\n    - [x] weak self\r\n    - [x] trailing closures\r\n    - [x] implicit parameters\r\n  - [ ] Unowned\r\n  - [x] Extensions on structs\r\n  - [x] Extensions to organize classes\r\n  - [x] Protocols on structs\r\n  - [ ] Swift 2 protocol extensions\r\n  - [x] Tuples, with labels\r\n  - [x] Trailing closures\r\n  - [ ] @Lazy\r\n  - [x] Pure Swift weak delegates via @class\r\n  - [x] Optionals\r\n  - [x] Convenience initializers\r\n  - [x] Failable initializers\r\n  - [x] Class variables on structs\r\n  - [x] CConstPointer, CConstVoidPointer\r\n    - [x] withCString {}\r\n  - [x] UnsafePointer\r\n  - [x] sizeof()\r\n  - [x] strideof()\r\n  - [x] Standard Protocols\r\n    - [x] Printable\r\n    - [x] BooleanType (aka LogicValue[1.x] aka Boolean[3.x])\r\n    - [x] OutputStreamType / Swift 3 OutputStream\r\n    - [x] Equatable\r\n      - [ ] Equatable on Enums with Associated Values\r\n    - [x] Hashable\r\n    - [x] SequenceType (GeneratorOf<T>)\r\n      - [x] Swift 3 Sequence (Iterator<T>)\r\n    - [x] Literal Convertibles\r\n      - [x] StringLiteralConvertible\r\n      - [ ] IntegerLiteralConvertible\r\n  - [x] Left shift AND right shift\r\n  - [x] Enums on steroids\r\n  - [ ] Dynamic type system, reflection\r\n  - [x] Operator overloading\r\n  - [ ] UCS-4 identifiers (🐔🐔🐔)\r\n  - [ ] ~~RTF source code with images and code sections in different fonts~~\r\n  - [ ] Nested classes/types\r\n  - [ ] Patterns\r\n    - [x] Use wildcard pattern to ignore value\r\n  - [x] Literal Convertibles\r\n  - [ ] @autoclosure\r\n  - [ ] unsafeBitCast (was reinterpretCast)\r\n  - [x] final\r\n  - [x] Nil coalescing operator\r\n  - [ ] dynamic\r\n  - [ ] Swift 2\r\n    - [ ] availability\r\n    - [x] guard\r\n    - [x] defer\r\n    - [ ] C function pointers\r\n    - [x] debugPrint\r\n    - [ ] lowercaseString\r\n  - [x] #if os(Linux)\r\n  - [ ] #if swift(>=2.2)\r\n- [x] Swift Package Manager\r\n  - [x] GNUmakefile support\r\n  - [ ] #if SWIFT_PACKAGE\r\n- [x] Linux support\r\n- [x] Swift 3 2016-03-16\r\n\r\n###Why?!\r\n\r\nThis is an experiment to get acquainted with Swift. To check whether something\r\nreal can be implemented in 'pure' Swift. Meaning, without using any Objective-C\r\nCocoa classes (no NS'ism).\r\nOr in other words: Can you use Swift without writing all the 'real' code in\r\nwrapped Objective-C? :-)\r\n\r\n###Contact\r\n\r\n[@helje5](http://twitter.com/helje5) | helge@alwaysrightinstitute.com\r\n\r\n![](http://www.alwaysrightinstitute.com/images/ARI-symbol-logo.png)\r\n",
  "google": "",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}